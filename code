# zhajinhua.py
# CLI æ‰é‡‘èŠ±ï¼ˆç‚¸é‡‘èŠ±ï¼‰- çº¯æ ‡å‡†åº“ + è¯ˆå”¬/è¯´è¯ç­–ç•¥
import random
from typing import List, Tuple, Optional

SUITS = ["â™ ", "â™¥", "â™£", "â™¦"]  # ä»å¤§åˆ°å°
RANKS = ["2","3","4","5","6","7","8","9","10","J","Q","K","A"]
RANK_VALUE = {r:i for i,r in enumerate(RANKS, start=2)}  # 2->2 ... A->14
SUIT_VALUE = {"â™ ":4, "â™¥":3, "â™£":2, "â™¦":1}                # æ¯”èŠ±è‰²æ—¶ç”¨

# ç‰Œå‹æƒé‡ï¼šæ•°å­—è¶Šå¤§è¶Šå¼º
HAND_TYPE = {
    "trips": 6,        # è±¹å­ï¼ˆä¸‰æ¡ï¼‰
    "straight_flush":5,# é¡ºé‡‘ï¼ˆåŒèŠ±é¡ºï¼‰
    "flush":4,         # é‡‘èŠ±ï¼ˆåŒèŠ±ï¼‰
    "straight":3,      # é¡ºå­
    "pair":2,          # å¯¹å­
    "high":1           # å•å¼ 
}

class Card:
    def __init__(self, rank: str, suit: str):
        self.rank = rank
        self.suit = suit
    def __repr__(self):
        return f"{self.rank}{self.suit}"

class Deck:
    def __init__(self):
        self.cards = [Card(r,s) for s in SUITS for r in RANKS]
    def shuffle(self, seed: Optional[int]=None):
        if seed is not None:
            random.seed(seed)
        random.shuffle(self.cards)
    def deal(self, n:int) -> List[Card]:
        if len(self.cards) < n:
            raise RuntimeError("ç‰Œä¸å¤Ÿäº†")
        hand = self.cards[:n]
        self.cards = self.cards[n:]
        return hand

def is_consecutive(vals: List[int]) -> bool:
    s = sorted(vals)
    if s[0]+1 == s[1] and s[1]+1 == s[2]:
        return True
    # A,2,3 ç‰¹ä¾‹ï¼šæŠŠ A(14) å½“ 1
    if set(s) == {14,2,3}:
        return True
    return False

def normalize_straight(vals: List[int]) -> List[int]:
    # é¡ºå­æ¯”è¾ƒæ—¶ï¼ŒA23 ä½œä¸ºæœ€å°é¡ºå­
    s = sorted(vals, reverse=True)
    if set(vals) == {14,2,3}:   # A23
        return [3,2,1]
    return s

def hand_rank(cards: List[Card]) -> Tuple[int, List[int], List[int]]:
    """
    è¿”å›ç”¨äºæ¯”è¾ƒå¤§å°çš„å…ƒç»„ï¼š(ç‰Œå‹å¼ºåº¦, ä¸»æ¯”è¾ƒé”®åˆ—è¡¨, æ¬¡æ¯”è¾ƒé”®åˆ—è¡¨)
    """
    ranks = [RANK_VALUE[c.rank] for c in cards]
    suits = [c.suit for c in cards]
    counts = {}
    for v in ranks:
        counts[v] = counts.get(v,0)+1
    unique = sorted(counts.items(), key=lambda x:(x[1], x[0]), reverse=True) # é¢‘æ¬¡+ç‚¹æ•°

    is_flush = len(set(suits)) == 1
    consec = is_consecutive(ranks)

    # ä¸‰æ¡
    if 3 in counts.values():
        tval = unique[0][0]
        return (HAND_TYPE["trips"], [tval], sorted([v for v in ranks if v!=tval], reverse=True))
    # åŒèŠ±é¡º
    if is_flush and consec:
        main = normalize_straight(ranks)
        return (HAND_TYPE["straight_flush"], main, [])
    # åŒèŠ±
    if is_flush:
        return (HAND_TYPE["flush"], sorted(ranks, reverse=True), [])
    # é¡ºå­
    if consec:
        main = normalize_straight(ranks)
        return (HAND_TYPE["straight"], main, [])
    # å¯¹å­
    if 2 in counts.values():
        pair_val = [v for v,cnt in counts.items() if cnt==2][0]
        kicker = [v for v in ranks if v!=pair_val][0]
        return (HAND_TYPE["pair"], [pair_val, kicker], [])
    # å•å¼ 
    return (HAND_TYPE["high"], sorted(ranks, reverse=True), [])

def highest_suit(cards: List[Card]) -> int:
    return max(SUIT_VALUE[c.suit] for c in cards)

def compare_hands(a: List[Card], b: List[Card]) -> int:
    """
    æ¯”è¾ƒä¸¤æ‰‹ç‰Œï¼š1 è¡¨ç¤º a èƒœï¼Œ-1 è¡¨ç¤º b èƒœï¼Œ0 è¡¨ç¤ºå®Œå…¨å¹³æ‰‹
    """
    ra = hand_rank(a)
    rb = hand_rank(b)
    if ra[0] != rb[0]:
        return 1 if ra[0] > rb[0] else -1
    for x, y in zip(ra[1], rb[1]):  # ä¸»é”®
        if x != y:
            return 1 if x > y else -1
    for x, y in zip(ra[2], rb[2]):  # æ¬¡é”®
        if x != y:
            return 1 if x > y else -1
    ha = highest_suit(a)
    hb = highest_suit(b)
    if ha != hb:
        return 1 if ha > hb else -1
    return 0

class Player:
    def __init__(self, name: str, chips: int, is_bot: bool):
        self.name = name
        self.chips = chips
        self.is_bot = is_bot
        self.alive = True        # æ˜¯å¦æœªå¼ƒç‰Œ
        self.seen = False        # æ˜¯å¦çœ‹ç‰Œ
        self.hand: List[Card] = []
        self.last_bluff_round = -1  # ä¸Šä¸€æ¬¡å‘è¨€çš„è½®æ¬¡ï¼ˆé¿å…ä¸€è½®å¤šæ¬¡å‘è¨€ï¼‰
    def __repr__(self):
        st = "BOT" if self.is_bot else "YOU"
        return f"{self.name}({st}) ä½™é¢:{self.chips}"

class Table:
    def __init__(self, players: List[Player], ante: int=10, min_bet: int=10, max_rounds: int=3):
        self.players = players
        self.ante = ante
        self.min_bet = min_bet
        self.max_rounds = max_rounds
        self.deck = Deck()
        self.pot = 0
        self.cur_bet = min_bet
        self.last_raiser = None

    def collect_ante(self):
        for p in self.players:
            pay = min(self.ante, p.chips)
            p.chips -= pay
            self.pot += pay

    def active_players(self) -> List[Player]:
        return [p for p in self.players if p.alive and p.chips >= 0]

    def deal(self):
        self.deck = Deck()
        self.deck.shuffle()
        for p in self.players:
            p.hand = self.deck.deal(3)
            p.alive = True
            p.seen = False
            p.last_bluff_round = -1

    def show_state(self):
        print("\n==== æ¡Œé¢ä¿¡æ¯ ====")
        print(f"åº•æ± ï¼š{self.pot} | å½“å‰è·Ÿæ³¨ï¼š{self.cur_bet}")
        for p in self.players:
            status = "åœ¨å±€" if p.alive else "å¼ƒç‰Œ"
            seen = "çœ‹ç‰Œ" if p.seen else "é—·ç‰Œ"
            me = "(ä½ )" if not p.is_bot else ""
            print(f"- {p.name}{me}: ç­¹ç  {p.chips} | {status} | {seen}")
        print("==================")

    # ------------------- è¯ˆå”¬ç³»ç»Ÿï¼ˆç©å®¶ï¼‰ -------------------
    def choose_bluff_phrase(self, player: Player, round_idx: int):
        if not player.seen:
            return
        if player.last_bluff_round == round_idx:
            return  # è¿™ä¸€è½®å·²ç»è¯´è¿‡ä¸€æ¬¡
        print("\né€‰æ‹©ä½ çš„è¨€è¯­ç­–ç•¥:")
        options = [
            "å¾—æ„æ´‹æ´‹ï¼ˆå“å”¬åˆ«äººï¼‰",
            "å‡è£…æ²®ä¸§ï¼ˆè£…ä½œç‰Œå°ï¼‰",
            "è¯šå®åœ°å¹æ°”ï¼ˆç‰Œå°ï¼‰",
            "è¯šå®åœ°è‡ªä¿¡ï¼ˆç‰Œå¤§ï¼‰",
            "ä¿æŒæ²‰é»˜"
        ]
        for i, opt in enumerate(options, 1):
            print(f"{i}) {opt}")
        try:
            choice = int(input("ä½ çš„é€‰æ‹© (1-5): ").strip())
        except:
            choice = 5
        phrases = {
            1: "å“ˆå“ˆï¼Œè¿™ç‰Œæˆ‘éƒ½ä¸å¥½æ„æ€å‡ºæ‰‹äº†ï½ğŸ˜",
            2: "å”‰ï¼Œä»Šå¤©æ‰‹æ°”çœŸå·®â€¦â€¦",
            3: "å“å‘€ï¼Œä¸æƒ³çœ‹éƒ½çŸ¥é“å®Œäº†ï½",
            4: "å°±è¿™ï¼Ÿç¨³äº†ç¨³äº†ğŸ˜",
            5: "ï¼ˆä½ é€‰æ‹©äº†æ²‰é»˜ï¼‰"
        }
        print(f"ä½ è¯´ï¼š{phrases.get(choice, 'ï¼ˆæ²‰é»˜ï¼‰')}")
        player.last_bluff_round = round_idx

    # ------------------- è¯ˆå”¬ç³»ç»Ÿï¼ˆæœºå™¨äººï¼‰ -------------------
    def bot_speak(self, bot: Player, strength: float, round_idx: int):
        if not bot.seen:
            return
        if bot.last_bluff_round == round_idx:
            return
        phrases_strong = [
            "è¿™ç‰Œä¸é”™å•Šï¼Œå“ˆå“ˆï½ğŸ˜",
            "å‘µå‘µï¼Œè¿™å±€ä½ ä»¬å±é™©äº†ï½",
            "ç¨³ç¨³çš„ï¼Œç¨³ç¨³çš„ã€‚",
            "åˆ«ç´§å¼ ï¼Œæˆ‘æ‰‹æ°”ä¸€èˆ¬ğŸ˜Œ"
        ]
        phrases_weak = [
            "å”‰ï¼Œè¿™æ‰‹æœ‰ç‚¹å°´å°¬â€¦â€¦",
            "å“å‘€ï¼Œè¿™ä¸‹æƒ¨äº†ã€‚",
            "ä»Šå¤©è¿æ°”ä¸å¤ªå¥½ã€‚",
            "ï¼ˆæ²‰é»˜ä¸è¯­ï¼Œéœ²å‡ºç¬‘å®¹ï¼‰"
        ]
        # å¼ºç‰Œä¹Ÿå¯èƒ½è£…å¼±ï¼Œå¼±ç‰Œä¹Ÿå¯èƒ½è£…å¼º
        if strength > 0.7:
            msg = random.choice(phrases_strong if random.random()>0.35 else phrases_weak)
        else:
            msg = random.choice(phrases_weak if random.random()>0.35 else phrases_strong)
        print(f"{bot.name} è¯´ï¼š{msg}")
        bot.last_bluff_round = round_idx

    # ------------------- å›åˆåŠ¨ä½œ -------------------
    def player_action(self, p: Player, round_idx: int):
        if not p.alive or p.chips <= 0:
            return

        if p.is_bot:
            self.bot_action(p, round_idx)
            return

        # äººç±»ç©å®¶
        print(f"\nä½ çš„æ‰‹ç‰Œï¼š{' '.join(map(str,p.hand)) if p.seen else 'ï¼ˆæœªçœ‹ç‰Œï¼Œè¾“å…¥ K çœ‹ç‰Œï¼‰'}")

        # è‹¥å·²ç»çœ‹ç‰Œï¼Œå…ˆé€‰æ‹©æœ¬è½®çš„è¨€è¯­ç­–ç•¥ï¼ˆåªå‡ºç°ä¸€æ¬¡/è½®ï¼‰
        if p.seen:
            self.choose_bluff_phrase(p, round_idx)

        while True:
            print(f"[F]å¼ƒç‰Œ  [C]è·Ÿæ³¨({self.cur_bet})  [R]åŠ æ³¨  [V]æ¯”ç‰Œ  [K]çœ‹ç‰Œ")
            cmd = input("ä½ çš„æ“ä½œ: ").strip().lower()
            if cmd == "k":
                if p.seen:
                    print("ä½ å·²ç»çœ‹è¿‡ç‰Œäº†ã€‚")
                else:
                    p.seen = True
                    print(f"ä½ çœ‹äº†ç‰Œï¼š{' '.join(map(str,p.hand))}")
                    # åˆšçœ‹ç‰Œï¼Œå…è®¸å½“è½®é€‰æ‹©ä¸€æ¬¡è¯æœ¯
                    self.choose_bluff_phrase(p, round_idx)
                continue
            elif cmd == "f":
                p.alive = False
                print("ä½ å¼ƒç‰Œäº†ã€‚")
                return
            elif cmd == "c":
                self.call_bet(p)
                return
            elif cmd == "r":
                self.raise_bet(p)
                return
            elif cmd == "v":
                self.challenge_compare(p)
                return
            else:
                print("æ— æ•ˆæŒ‡ä»¤ï¼Œè¯·é‡è¯•ã€‚")

    def call_bet(self, p: Player):
        pay = min(self.cur_bet, p.chips)
        p.chips -= pay
        self.pot += pay
        print(f"{p.name} è·Ÿæ³¨ {pay}")

    def raise_bet(self, p: Player):
        max_raise = p.chips
        if max_raise < self.cur_bet:
            print("ç­¹ç ä¸è¶³ä»¥åŠ æ³¨ï¼Œè‡ªåŠ¨æ”¹ä¸ºè·Ÿæ³¨ã€‚")
            self.call_bet(p)
            return
        try:
            amt = int(input(f"åŠ æ³¨å¤šå°‘(>= {self.cur_bet}, <= {max_raise}): ").strip())
        except:
            print("è¾“å…¥æ— æ•ˆï¼Œè‡ªåŠ¨è·Ÿæ³¨ã€‚")
            self.call_bet(p)
            return
        if amt < self.cur_bet:
            print("ä¸è¶³ä»¥åŠ æ³¨ï¼Œè‡ªåŠ¨è·Ÿæ³¨ã€‚")
            self.call_bet(p)
            return
        p.chips -= amt
        self.pot += amt
        self.cur_bet = amt
        self.last_raiser = p
        print(f"{p.name} åŠ æ³¨åˆ° {amt}")

    def challenge_compare(self, attacker: Player):
        targets = [q for q in self.players if q.alive and q is not attacker]
        if not targets:
            print("æ— äººå¯æ¯”ï¼Œæ“ä½œè½¬ä¸ºè·Ÿæ³¨ã€‚")
            self.call_bet(attacker)
            return
        for i, q in enumerate(targets, start=1):
            print(f"{i}) {q.name} {'(é—·ç‰Œ)' if not q.seen else ''}")
        try:
            idx = int(input("é€‰æ‹©è¦æ¯”ç‰Œçš„ç©å®¶åºå·: ").strip())
            target = targets[idx-1]
        except:
            print("é€‰æ‹©æ— æ•ˆï¼Œé»˜è®¤é€‰ç¬¬ä¸€ä¸ªã€‚")
            target = targets[0]

        cost = min(self.cur_bet, attacker.chips)
        attacker.chips -= cost
        self.pot += cost
        print(f"{attacker.name} å‘ {target.name} å‘èµ·æ¯”ç‰Œï¼(æ¯”ç‰Œè´¹ {cost})")
        self.reveal_and_eliminate(attacker, target)

    def reveal_and_eliminate(self, a: Player, b: Player):
        print(f"  {a.name} çš„ç‰Œï¼š{' '.join(map(str,a.hand))}")
        print(f"  {b.name} çš„ç‰Œï¼š{' '.join(map(str,b.hand))}")
        res = compare_hands(a.hand, b.hand)
        if res >= 0:
            print(f"  {a.name} è·èƒœï¼Œ{b.name} å‡ºå±€ã€‚")
            b.alive = False
        else:
            print(f"  {b.name} è·èƒœï¼Œ{a.name} å‡ºå±€ã€‚")
            a.alive = False

    # â€”â€” æœºå™¨äººé€»è¾‘ â€”â€”ï¼ˆå«è¯ˆå”¬å‘è¨€ï¼‰
    def bot_action(self, p: Player, round_idx: int):
        strength = self.estimate_strength(p.hand)

        # å†³å®šçœ‹ä¸çœ‹ç‰Œ
        if not p.seen and (strength >= 0.75 or random.random() < 0.35):
            p.seen = True

        # å¦‚æœçœ‹ç‰Œäº†ï¼Œå…ˆâ€œè¯´ä¸€å¥â€å¿ƒç†è¯ï¼ˆæ¯è½®ä¸€æ¬¡ï¼‰
        if p.seen:
            self.bot_speak(p, strength, round_idx)

        # ç­–ç•¥ï¼ˆç®€åŒ–ï¼‰
        action = "call"
        if strength >= 0.9 and p.chips >= self.cur_bet*2 and random.random() < 0.7:
            action = "raise"
        elif strength <= 0.25 and random.random() < 0.5:
            action = "fold"
        elif strength >= 0.6 and random.random() < 0.2 and len(self.active_players())>=2:
            action = "compare"

        if action == "fold":
            p.alive = False
            print(f"{p.name} å¼ƒç‰Œã€‚")
        elif action == "raise":
            amt = min(max(self.cur_bet*2, self.cur_bet), p.chips)
            if amt <= 0:
                self.call_bet(p)
                return
            p.chips -= amt
            self.pot += amt
            self.cur_bet = amt
            self.last_raiser = p
            print(f"{p.name} åŠ æ³¨åˆ° {amt}")
        elif action == "compare":
            targets = [q for q in self.players if q.alive and q is not p]
            human = [q for q in targets if not q.is_bot]
            target = human[0] if human else random.choice(targets)
            cost = min(self.cur_bet, p.chips)
            p.chips -= cost
            self.pot += cost
            print(f"{p.name} å‘ {target.name} å‘èµ·æ¯”ç‰Œï¼ï¼ˆæ¯”ç‰Œè´¹ {cost}ï¼‰")
            self.reveal_and_eliminate(p, target)
        else:
            self.call_bet(p)

    def estimate_strength(self, hand: List[Card]) -> float:
        t, main, _ = hand_rank(hand)
        base = {HAND_TYPE["high"]:0.35, HAND_TYPE["pair"]:0.6,
                HAND_TYPE["straight"]:0.75, HAND_TYPE["flush"]:0.78,
                HAND_TYPE["straight_flush"]:0.92, HAND_TYPE["trips"]:0.98}[t]
        hi = max(RANK_VALUE[c.rank] for c in hand)
        bonus = (hi-6)/10.0  # 6~14 â†’ ~0..0.8
        return max(0.0, min(1.0, base + bonus*0.1))

    def settle(self):
        alive = [p for p in self.players if p.alive]
        if len(alive) == 1:
            winner = alive[0]
            winner.chips += self.pot
            print(f"\n*** {winner.name} ç›´æ¥è·èƒœï¼Œèµ¢å¾—åº•æ±  {self.pot} ***")
        else:
            print("\n--- æ‘Šç‰Œ ---")
            best = None
            winners = []
            for p in alive:
                print(f"{p.name}: {' '.join(map(str,p.hand))}")
                r = hand_rank(p.hand)
                tup = (r, highest_suit(p.hand))
                if (best is None) or (tup > best):
                    best = tup
                    winners = [p]
                elif tup == best:
                    winners.append(p)
            share = self.pot // len(winners)
            for w in winners:
                w.chips += share
            names = ", ".join(p.name for p in winners)
            print(f"*** èƒœè€…ï¼š{names}ï¼Œæ¯äººåˆ†å¾— {share} ***")

    def play_hand(self):
        self.pot = 0
        self.cur_bet = self.min_bet
        self.last_raiser = None
        self.deal()
        self.collect_ante()
        print("\n================= æ–°çš„ä¸€å±€ =================")
        self.show_state()

        for r in range(1, self.max_rounds+1):
            print(f"\nâ€”â€” ç¬¬ {r} è½® â€”â€”")
            for p in self.players:
                if len(self.active_players()) <= 1:
                    break
                if not p.alive or p.chips <= 0:
                    continue
                self.player_action(p, r)
                if len(self.active_players()) <= 1:
                    break
            self.show_state()
            if len(self.active_players()) <= 1:
                break
        self.settle()

def ask_int(prompt: str, low: int, high: int, default: Optional[int]=None) -> int:
    while True:
        s = input(f"{prompt} ").strip()
        if not s and default is not None:
            return default
        try:
            v = int(s)
            if low <= v <= high:
                return v
        except:
            pass
        print(f"è¯·è¾“å…¥ {low}~{high} çš„æ•´æ•°ã€‚")

def main():
    print("=== æ‰é‡‘èŠ±ï¼ˆå‘½ä»¤è¡Œç‰ˆï¼‰===")
    n = ask_int("ç©å®¶æ€»æ•°(2~6ï¼Œå«ä½ )ï¼š", 2, 6, 3)
    bots = max(0, n-1)
    init_chips = ask_int("æ¯ä½åˆå§‹ç­¹ç (å»ºè®® >=100)ï¼š", 20, 100000, 200)
    ante = ask_int("åº•æ³¨(å»ºè®® 5~20)ï¼š", 1, 1000, 10)
    min_bet = ask_int("æœ€å°è·Ÿæ³¨(å»ºè®® 10~50)ï¼š", 1, 10000, 20)
    max_rounds = ask_int("æœ€å¤šä¸‹æ³¨è½®æ•°(1~5)ï¼š", 1, 5, 3)

    players: List[Player] = []
    players.append(Player("You", init_chips, is_bot=False))
    for i in range(bots):
        players.append(Player(f"Bot{i+1}", init_chips, is_bot=True))

    table = Table(players, ante=ante, min_bet=min_bet, max_rounds=max_rounds)

    while True:
        rich = [p for p in table.players if p.chips > 0]
        if len(rich) < 2:
            alive = rich[0] if rich else None
            if alive:
                print(f"\næ¸¸æˆç»“æŸï¼{alive.name} æ‹¿ä¸‹å…¨éƒ¨ç­¹ç ã€‚")
            else:
                print("\næ¸¸æˆç»“æŸï¼æ‰€æœ‰äººç ´äº§ï¼ˆï¼Ÿï¼‰")
            break
        table.play_hand()
        print("\n--- æœ¬å±€ç»“æŸï¼Œä½™é¢ ---")
        for p in table.players:
            print(f"{p.name}: {p.chips}")
        go = input("\nç»§ç»­ä¸‹ä¸€å±€ï¼Ÿ(Y/n): ").strip().lower()
        if go == "n":
            print("æ„Ÿè°¢æ¸¸ç©ï¼Œç†æ€§å¨±ä¹ï½")
            break

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nå·²é€€å‡ºã€‚")

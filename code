# zhajinhua.py
# CLI 扎金花（炸金花）- 纯标准库 + 诈唬/说话策略
import random
from typing import List, Tuple, Optional

SUITS = ["♠", "♥", "♣", "♦"]  # 从大到小
RANKS = ["2","3","4","5","6","7","8","9","10","J","Q","K","A"]
RANK_VALUE = {r:i for i,r in enumerate(RANKS, start=2)}  # 2->2 ... A->14
SUIT_VALUE = {"♠":4, "♥":3, "♣":2, "♦":1}                # 比花色时用

# 牌型权重：数字越大越强
HAND_TYPE = {
    "trips": 6,        # 豹子（三条）
    "straight_flush":5,# 顺金（同花顺）
    "flush":4,         # 金花（同花）
    "straight":3,      # 顺子
    "pair":2,          # 对子
    "high":1           # 单张
}

class Card:
    def __init__(self, rank: str, suit: str):
        self.rank = rank
        self.suit = suit
    def __repr__(self):
        return f"{self.rank}{self.suit}"

class Deck:
    def __init__(self):
        self.cards = [Card(r,s) for s in SUITS for r in RANKS]
    def shuffle(self, seed: Optional[int]=None):
        if seed is not None:
            random.seed(seed)
        random.shuffle(self.cards)
    def deal(self, n:int) -> List[Card]:
        if len(self.cards) < n:
            raise RuntimeError("牌不够了")
        hand = self.cards[:n]
        self.cards = self.cards[n:]
        return hand

def is_consecutive(vals: List[int]) -> bool:
    s = sorted(vals)
    if s[0]+1 == s[1] and s[1]+1 == s[2]:
        return True
    # A,2,3 特例：把 A(14) 当 1
    if set(s) == {14,2,3}:
        return True
    return False

def normalize_straight(vals: List[int]) -> List[int]:
    # 顺子比较时，A23 作为最小顺子
    s = sorted(vals, reverse=True)
    if set(vals) == {14,2,3}:   # A23
        return [3,2,1]
    return s

def hand_rank(cards: List[Card]) -> Tuple[int, List[int], List[int]]:
    """
    返回用于比较大小的元组：(牌型强度, 主比较键列表, 次比较键列表)
    """
    ranks = [RANK_VALUE[c.rank] for c in cards]
    suits = [c.suit for c in cards]
    counts = {}
    for v in ranks:
        counts[v] = counts.get(v,0)+1
    unique = sorted(counts.items(), key=lambda x:(x[1], x[0]), reverse=True) # 频次+点数

    is_flush = len(set(suits)) == 1
    consec = is_consecutive(ranks)

    # 三条
    if 3 in counts.values():
        tval = unique[0][0]
        return (HAND_TYPE["trips"], [tval], sorted([v for v in ranks if v!=tval], reverse=True))
    # 同花顺
    if is_flush and consec:
        main = normalize_straight(ranks)
        return (HAND_TYPE["straight_flush"], main, [])
    # 同花
    if is_flush:
        return (HAND_TYPE["flush"], sorted(ranks, reverse=True), [])
    # 顺子
    if consec:
        main = normalize_straight(ranks)
        return (HAND_TYPE["straight"], main, [])
    # 对子
    if 2 in counts.values():
        pair_val = [v for v,cnt in counts.items() if cnt==2][0]
        kicker = [v for v in ranks if v!=pair_val][0]
        return (HAND_TYPE["pair"], [pair_val, kicker], [])
    # 单张
    return (HAND_TYPE["high"], sorted(ranks, reverse=True), [])

def highest_suit(cards: List[Card]) -> int:
    return max(SUIT_VALUE[c.suit] for c in cards)

def compare_hands(a: List[Card], b: List[Card]) -> int:
    """
    比较两手牌：1 表示 a 胜，-1 表示 b 胜，0 表示完全平手
    """
    ra = hand_rank(a)
    rb = hand_rank(b)
    if ra[0] != rb[0]:
        return 1 if ra[0] > rb[0] else -1
    for x, y in zip(ra[1], rb[1]):  # 主键
        if x != y:
            return 1 if x > y else -1
    for x, y in zip(ra[2], rb[2]):  # 次键
        if x != y:
            return 1 if x > y else -1
    ha = highest_suit(a)
    hb = highest_suit(b)
    if ha != hb:
        return 1 if ha > hb else -1
    return 0

class Player:
    def __init__(self, name: str, chips: int, is_bot: bool):
        self.name = name
        self.chips = chips
        self.is_bot = is_bot
        self.alive = True        # 是否未弃牌
        self.seen = False        # 是否看牌
        self.hand: List[Card] = []
        self.last_bluff_round = -1  # 上一次发言的轮次（避免一轮多次发言）
    def __repr__(self):
        st = "BOT" if self.is_bot else "YOU"
        return f"{self.name}({st}) 余额:{self.chips}"

class Table:
    def __init__(self, players: List[Player], ante: int=10, min_bet: int=10, max_rounds: int=3):
        self.players = players
        self.ante = ante
        self.min_bet = min_bet
        self.max_rounds = max_rounds
        self.deck = Deck()
        self.pot = 0
        self.cur_bet = min_bet
        self.last_raiser = None

    def collect_ante(self):
        for p in self.players:
            pay = min(self.ante, p.chips)
            p.chips -= pay
            self.pot += pay

    def active_players(self) -> List[Player]:
        return [p for p in self.players if p.alive and p.chips >= 0]

    def deal(self):
        self.deck = Deck()
        self.deck.shuffle()
        for p in self.players:
            p.hand = self.deck.deal(3)
            p.alive = True
            p.seen = False
            p.last_bluff_round = -1

    def show_state(self):
        print("\n==== 桌面信息 ====")
        print(f"底池：{self.pot} | 当前跟注：{self.cur_bet}")
        for p in self.players:
            status = "在局" if p.alive else "弃牌"
            seen = "看牌" if p.seen else "闷牌"
            me = "(你)" if not p.is_bot else ""
            print(f"- {p.name}{me}: 筹码 {p.chips} | {status} | {seen}")
        print("==================")

    # ------------------- 诈唬系统（玩家） -------------------
    def choose_bluff_phrase(self, player: Player, round_idx: int):
        if not player.seen:
            return
        if player.last_bluff_round == round_idx:
            return  # 这一轮已经说过一次
        print("\n选择你的言语策略:")
        options = [
            "得意洋洋（吓唬别人）",
            "假装沮丧（装作牌小）",
            "诚实地叹气（牌小）",
            "诚实地自信（牌大）",
            "保持沉默"
        ]
        for i, opt in enumerate(options, 1):
            print(f"{i}) {opt}")
        try:
            choice = int(input("你的选择 (1-5): ").strip())
        except:
            choice = 5
        phrases = {
            1: "哈哈，这牌我都不好意思出手了～😏",
            2: "唉，今天手气真差……",
            3: "哎呀，不想看都知道完了～",
            4: "就这？稳了稳了😎",
            5: "（你选择了沉默）"
        }
        print(f"你说：{phrases.get(choice, '（沉默）')}")
        player.last_bluff_round = round_idx

    # ------------------- 诈唬系统（机器人） -------------------
    def bot_speak(self, bot: Player, strength: float, round_idx: int):
        if not bot.seen:
            return
        if bot.last_bluff_round == round_idx:
            return
        phrases_strong = [
            "这牌不错啊，哈哈～😏",
            "呵呵，这局你们危险了～",
            "稳稳的，稳稳的。",
            "别紧张，我手气一般😌"
        ]
        phrases_weak = [
            "唉，这手有点尴尬……",
            "哎呀，这下惨了。",
            "今天运气不太好。",
            "（沉默不语，露出笑容）"
        ]
        # 强牌也可能装弱，弱牌也可能装强
        if strength > 0.7:
            msg = random.choice(phrases_strong if random.random()>0.35 else phrases_weak)
        else:
            msg = random.choice(phrases_weak if random.random()>0.35 else phrases_strong)
        print(f"{bot.name} 说：{msg}")
        bot.last_bluff_round = round_idx

    # ------------------- 回合动作 -------------------
    def player_action(self, p: Player, round_idx: int):
        if not p.alive or p.chips <= 0:
            return

        if p.is_bot:
            self.bot_action(p, round_idx)
            return

        # 人类玩家
        print(f"\n你的手牌：{' '.join(map(str,p.hand)) if p.seen else '（未看牌，输入 K 看牌）'}")

        # 若已经看牌，先选择本轮的言语策略（只出现一次/轮）
        if p.seen:
            self.choose_bluff_phrase(p, round_idx)

        while True:
            print(f"[F]弃牌  [C]跟注({self.cur_bet})  [R]加注  [V]比牌  [K]看牌")
            cmd = input("你的操作: ").strip().lower()
            if cmd == "k":
                if p.seen:
                    print("你已经看过牌了。")
                else:
                    p.seen = True
                    print(f"你看了牌：{' '.join(map(str,p.hand))}")
                    # 刚看牌，允许当轮选择一次话术
                    self.choose_bluff_phrase(p, round_idx)
                continue
            elif cmd == "f":
                p.alive = False
                print("你弃牌了。")
                return
            elif cmd == "c":
                self.call_bet(p)
                return
            elif cmd == "r":
                self.raise_bet(p)
                return
            elif cmd == "v":
                self.challenge_compare(p)
                return
            else:
                print("无效指令，请重试。")

    def call_bet(self, p: Player):
        pay = min(self.cur_bet, p.chips)
        p.chips -= pay
        self.pot += pay
        print(f"{p.name} 跟注 {pay}")

    def raise_bet(self, p: Player):
        max_raise = p.chips
        if max_raise < self.cur_bet:
            print("筹码不足以加注，自动改为跟注。")
            self.call_bet(p)
            return
        try:
            amt = int(input(f"加注多少(>= {self.cur_bet}, <= {max_raise}): ").strip())
        except:
            print("输入无效，自动跟注。")
            self.call_bet(p)
            return
        if amt < self.cur_bet:
            print("不足以加注，自动跟注。")
            self.call_bet(p)
            return
        p.chips -= amt
        self.pot += amt
        self.cur_bet = amt
        self.last_raiser = p
        print(f"{p.name} 加注到 {amt}")

    def challenge_compare(self, attacker: Player):
        targets = [q for q in self.players if q.alive and q is not attacker]
        if not targets:
            print("无人可比，操作转为跟注。")
            self.call_bet(attacker)
            return
        for i, q in enumerate(targets, start=1):
            print(f"{i}) {q.name} {'(闷牌)' if not q.seen else ''}")
        try:
            idx = int(input("选择要比牌的玩家序号: ").strip())
            target = targets[idx-1]
        except:
            print("选择无效，默认选第一个。")
            target = targets[0]

        cost = min(self.cur_bet, attacker.chips)
        attacker.chips -= cost
        self.pot += cost
        print(f"{attacker.name} 向 {target.name} 发起比牌！(比牌费 {cost})")
        self.reveal_and_eliminate(attacker, target)

    def reveal_and_eliminate(self, a: Player, b: Player):
        print(f"  {a.name} 的牌：{' '.join(map(str,a.hand))}")
        print(f"  {b.name} 的牌：{' '.join(map(str,b.hand))}")
        res = compare_hands(a.hand, b.hand)
        if res >= 0:
            print(f"  {a.name} 获胜，{b.name} 出局。")
            b.alive = False
        else:
            print(f"  {b.name} 获胜，{a.name} 出局。")
            a.alive = False

    # —— 机器人逻辑 ——（含诈唬发言）
    def bot_action(self, p: Player, round_idx: int):
        strength = self.estimate_strength(p.hand)

        # 决定看不看牌
        if not p.seen and (strength >= 0.75 or random.random() < 0.35):
            p.seen = True

        # 如果看牌了，先“说一句”心理话（每轮一次）
        if p.seen:
            self.bot_speak(p, strength, round_idx)

        # 策略（简化）
        action = "call"
        if strength >= 0.9 and p.chips >= self.cur_bet*2 and random.random() < 0.7:
            action = "raise"
        elif strength <= 0.25 and random.random() < 0.5:
            action = "fold"
        elif strength >= 0.6 and random.random() < 0.2 and len(self.active_players())>=2:
            action = "compare"

        if action == "fold":
            p.alive = False
            print(f"{p.name} 弃牌。")
        elif action == "raise":
            amt = min(max(self.cur_bet*2, self.cur_bet), p.chips)
            if amt <= 0:
                self.call_bet(p)
                return
            p.chips -= amt
            self.pot += amt
            self.cur_bet = amt
            self.last_raiser = p
            print(f"{p.name} 加注到 {amt}")
        elif action == "compare":
            targets = [q for q in self.players if q.alive and q is not p]
            human = [q for q in targets if not q.is_bot]
            target = human[0] if human else random.choice(targets)
            cost = min(self.cur_bet, p.chips)
            p.chips -= cost
            self.pot += cost
            print(f"{p.name} 向 {target.name} 发起比牌！（比牌费 {cost}）")
            self.reveal_and_eliminate(p, target)
        else:
            self.call_bet(p)

    def estimate_strength(self, hand: List[Card]) -> float:
        t, main, _ = hand_rank(hand)
        base = {HAND_TYPE["high"]:0.35, HAND_TYPE["pair"]:0.6,
                HAND_TYPE["straight"]:0.75, HAND_TYPE["flush"]:0.78,
                HAND_TYPE["straight_flush"]:0.92, HAND_TYPE["trips"]:0.98}[t]
        hi = max(RANK_VALUE[c.rank] for c in hand)
        bonus = (hi-6)/10.0  # 6~14 → ~0..0.8
        return max(0.0, min(1.0, base + bonus*0.1))

    def settle(self):
        alive = [p for p in self.players if p.alive]
        if len(alive) == 1:
            winner = alive[0]
            winner.chips += self.pot
            print(f"\n*** {winner.name} 直接获胜，赢得底池 {self.pot} ***")
        else:
            print("\n--- 摊牌 ---")
            best = None
            winners = []
            for p in alive:
                print(f"{p.name}: {' '.join(map(str,p.hand))}")
                r = hand_rank(p.hand)
                tup = (r, highest_suit(p.hand))
                if (best is None) or (tup > best):
                    best = tup
                    winners = [p]
                elif tup == best:
                    winners.append(p)
            share = self.pot // len(winners)
            for w in winners:
                w.chips += share
            names = ", ".join(p.name for p in winners)
            print(f"*** 胜者：{names}，每人分得 {share} ***")

    def play_hand(self):
        self.pot = 0
        self.cur_bet = self.min_bet
        self.last_raiser = None
        self.deal()
        self.collect_ante()
        print("\n================= 新的一局 =================")
        self.show_state()

        for r in range(1, self.max_rounds+1):
            print(f"\n—— 第 {r} 轮 ——")
            for p in self.players:
                if len(self.active_players()) <= 1:
                    break
                if not p.alive or p.chips <= 0:
                    continue
                self.player_action(p, r)
                if len(self.active_players()) <= 1:
                    break
            self.show_state()
            if len(self.active_players()) <= 1:
                break
        self.settle()

def ask_int(prompt: str, low: int, high: int, default: Optional[int]=None) -> int:
    while True:
        s = input(f"{prompt} ").strip()
        if not s and default is not None:
            return default
        try:
            v = int(s)
            if low <= v <= high:
                return v
        except:
            pass
        print(f"请输入 {low}~{high} 的整数。")

def main():
    print("=== 扎金花（命令行版）===")
    n = ask_int("玩家总数(2~6，含你)：", 2, 6, 3)
    bots = max(0, n-1)
    init_chips = ask_int("每位初始筹码(建议 >=100)：", 20, 100000, 200)
    ante = ask_int("底注(建议 5~20)：", 1, 1000, 10)
    min_bet = ask_int("最小跟注(建议 10~50)：", 1, 10000, 20)
    max_rounds = ask_int("最多下注轮数(1~5)：", 1, 5, 3)

    players: List[Player] = []
    players.append(Player("You", init_chips, is_bot=False))
    for i in range(bots):
        players.append(Player(f"Bot{i+1}", init_chips, is_bot=True))

    table = Table(players, ante=ante, min_bet=min_bet, max_rounds=max_rounds)

    while True:
        rich = [p for p in table.players if p.chips > 0]
        if len(rich) < 2:
            alive = rich[0] if rich else None
            if alive:
                print(f"\n游戏结束！{alive.name} 拿下全部筹码。")
            else:
                print("\n游戏结束！所有人破产（？）")
            break
        table.play_hand()
        print("\n--- 本局结束，余额 ---")
        for p in table.players:
            print(f"{p.name}: {p.chips}")
        go = input("\n继续下一局？(Y/n): ").strip().lower()
        if go == "n":
            print("感谢游玩，理性娱乐～")
            break

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n已退出。")
